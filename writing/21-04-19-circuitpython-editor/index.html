<!DOCTYPE html>
<html lang="en">

<head>
    <title>Jacob Haip</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="/style.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans" rel="stylesheet">
    <script src="/script.js" defer></script>
    <style>
        .fact {
            font-family: monospace;
            background: #fff9cc;
            padding: 5px;
        }
        .system-code {
            color: purple;
        }
        .code-comment {
            color: darkgreen;
        }
    </style>
</head>

<body class="writing">
    <a href="/"><< Home</a>
    <p>
        <img src="banner.jpg" alt="setup" class="gallery-imagee" />
    </p>
        <h1>CircuitPython Editor</h1>
        <p><small>April 19, 2021</small></p>

        <p>I am exploring the idea of "programmable spaces" &mdash; where the concept of a computer is expanded outside a little
        rectangular screen to fill the entire room. Interacting with the programmable space means using physical objects, not
        virtual ones on a screen. Bringing computing to the scale of a room makes it a communal and social experience.
        </p>

        <p>
            I want to inspire and empower more people to make and personalize electronic objects in their homes.
            I made a new way to reprogram electronic boards inside these objects that is good for multiple people casually
            making changes to the objects, as opposed to the individualistic making experience today.
            Boards are reprogrammed by swapping out physical trading card-sized programs and when edits are needed,
            an integrated program editor is there.
            Objects are also build from the ground up to be connected to the rest of the room without any setup.
        </p>

        <p>
          <div style="padding:56.25% 0 0 0;position:relative;"><iframe
                  src="https://player.vimeo.com/video/541064361?byline=0&portrait=0"
                  style="position:absolute;top:0;left:0;width:100%;height:100%;" frameborder="0" allow="autoplay; fullscreen"
                  allowfullscreen></iframe></div>
          <center><small>Programming a Rasbperry Pi Pico by swapping cards, editing code, and printing updated code.</small></center>
        </p>

        <p>
          This is as continuation of prototype I did a year ago: https://haiperspace.com/writing/20-02-11-rfid-cards/
          but this time TODO TODO TODO
        </p>

        <h4>How programming electronics is focused on the individual</h4>

        <p>
          Firstly, each code and version is saved and edited on the original maker's personal computer.
          If someone else wants to see or edit code they have to deal with sharing and permission issues of
          getting someone else's code to their computer and learning how to edit it.

          Secondly, electronic devices themselves hide away their source code and capabilities.
          You may be able to get the current version of the code off a device, but not earlier versions or other demos.
          Trying to understand what the device does and can do requires you to have almost all the same knowledge and memories as the original maker.
          If someone else's goal is to just understand, play, or temporarily change a devices's behavior this is a big hurdle.
          These hurdles can make a fear of messing up the original maker's work and so other people are less likely
          to try and collaborate on it.
        </p>

        <p>
          When doing "serious work", it makes sense that programming revolves around a single person's computer,
          but I think shared spaces would benefit from trading a little bit of original maker efficiency for a
          more inviting experience for other people sharing the space.
        </p>

        <h4>A story about roommates making plant soil sensors</h4>

        <p>
          Two people are living together and they have some plants. One roommate keeps forgetting to water the plants so they come up
          with an idea for a soil moisture sensor that shows a red light when the soil is dry.
        </p>
        <p>
          They could just write it down on paper but it would be cooler to make someone yourself that was a little smarter than paper.
          They could just buy one but then you have to register for an account, rely on the company for updates, and don't have control
          of how it looks and what you want is pretty simple.
        </p>

        <h5>The story today</h5>

        <p>
          Roommate A is the more enthusiatic maker and so they buy a couple soil sensors and a few Circuit Playground Bluefruit electronic boards.
          They write some CircuitPython code using the Mu editor on their computer and save some different versions
          and tests to their desktop folder as they are working on getting the first sensor working.
          After the first sensor works, they plug in the second Bluefruit board and copy the working code verion they have saved on their Desktop.
          They then have the idea to make a dashboard that shows a smiling or frowning face to represent the status of each plant.
          They write some hacky code that is good enough to run on their computer for the two sensors that connects to
          the devices via Bluetooth.
        </p>
        <p>
          <img src="two-computers-editing.jpg" alt="setup" class="gallery-imagee" />
        </p>
        <p>
          A few weeks later, Roommate B buys another plant and wants to add in the same soil sensor and add it to the dashboard Roommate A set up.
          Roommate B is not an experienced maker and so they have no idea where to start or how the other two sensors work today.
          Roommate A explains to Roommate B that they need this code file and emails them so they have get it on their personal computer.
          With rommmate A telling Roommate A what to do other their shoulder, they are able to get the code running on the third sensor.
          Integrating the third sensor into the dashboard display is more annoying. Roommate B's code doesn't work on Roommate A's computer
          right away and it's too much hassle to get it working. Roommate A will just make the change.
        </p>

        <h5>How it could have been different</h5>

        <p>
          Roommate A still makes the original sensor, but instead using a text editor that is always-on in the room.
          The code they make is associated with a physical "program card". They put the program card on a stand connected
          to the text editor so that their code changes are saved to the card.
          They print the source code and make a little drawing so that the program card is identifiable and can be
          used to understand what the program does.
          When a new program card is put on the stand, it's code is automatically run on the board so programming the second
          second involves just plugging in the board and then putting the program card on the stand.
        </p>
        <p>
          <img src="programming-soil-sensor.jpg" alt="setup" class="gallery-imagee" />
        </p>
        <p>
          To make the plant smiley-face dashboard, Roommmate A makes a new [[Programmable Space]] program using
          a different program editor and program card in the room. A CircuitPython library and corresponding 
          Programmable Space proxy allows the Bluefruit to make claims about the soil sensor value to the Programmable Space
          without writing any Bluetooth code. The dashboard display code can subscribe to these claims about soil sensor
          values to make the smiley-face dashboard live updating and free of bluetooth specific code.
        </p>
        <p>
          <img src="making-smiley-dashboard.jpg" alt="setup" class="gallery-imagee" />
        </p>
        <p>
          When Roommate B wants to add the third sensor, Roommate B tells them to just plug in the new board
          and put the soil sensor card on the stand. There are also a could other program cards next to the editor
          and they try out the one labeled "rainbow" which shows rainbow light pattern on the board.
          They switch back to the soil sensor program card and then add the sensor to their new plant.
        </p>
        <p>
          <img src="other-demos-than-soil-sensor.jpg" alt="setup" class="gallery-imagee" />
        </p>
        <p>
          To edit the smiley-face dashboard, Roommate A shows B the program card for the dashboard and the text editor card.
          This change involves editing some code which Roommate B doesn't really understand, but luckily the
          change only involved copying a few lines of code out of the 30 lines of code for whole program.
        </p>
        <p>
          <img src="plant-card-and-dashboard.jpg" alt="setup" class="gallery-imagee" />
        </p>

        <h5>Summary</h5>
        
        <p>
          In the first story, Roommate A, the original maker, was heavily involved in every step of Roommate B's changes
          because they had the original ownership to the code and had to help Roommate A get of the technical hurdles
          of editing code.

          The second story, involved a simiilar process for the original maker but Roommate B had an easier time
          because they had ways to make basic changes without needing to understanding programming the boards on their own computer.
          When a little programming was needed for the smiley-face dashboard, they had a physical reference to keep them grounded.
          Roommates B also had an easier time making the dashboard because the integrate of the boards to the rest of programmable
          space allowed them to make this sort of distributed graphical program in a portable way and without needing
          to write hacky Bluetooth or GUI code - those things came for free by being part of the programmable space.
        </p>

        <h4>Program cards, editor, and room connection in detail</h4>

        <h5>Program cards</h5>
        <p>
          Program cards are just physical representation of code in a file on some computer.
          Physical representation is important so you can put the code physically next to
          the object you want to edit and see the options you have.
        </p>

        <p>
            <img src="program-card.jpg" alt="setup" class="gallery-imagee" />
        </p>

        <p>
          In my demo I have program cards containing both a printout of the full source code
          and a trading-card like front where you can make a drawing and write a short
          description of what the code does.
          
          The drawing makes the physical cards unique and brings a personal element them.

          The full source code is so someone could read or reference the code without
          needing to have it open on a computer editor.

          Each of these are optional but I found that code along isn't physically different
          enough to be a good label and that a drawing alone skips over important details of how things actually work.
        </p>

        <h5>Program sensing stand</h5>

        <p>
            <img src="program-stand.jpg" alt="setup" class="gallery-imagee" />
        </p>
        <p>
          Program cards are put on a stand that consists of an RFID sensor, some buttons,
          and an electronic board that tells the computer the ID of cards via USB.
          It could be made using the editor which I think is really cool.
          Causes the front of the program card to be printed and another prints the full source code.
        </p>

        <h5>Code Editor</h5>

        <p>
          <img src="editor-and-printer.jpg" alt="setup" class="gallery-imagee" />
        </p>
        <p>
          When creating something new or making edits more than just swapping a card, a text editor is used.
          I have a custom text editor so it could better integrate with the program stand,
          the board, and the code printer.
        </p>
        <p>
          There is no "open file" action because source code is shown when a board is plugged
          in or when a new card is put on the stand.

          When a program card is swapped it takes care of writing the program card to the plugged in board.

          The editor is a "programmable space" program in that it makes claims and subscriptions to the room broker
          to get program source code, editor source code, and wish code would be thermal printed.

          There is also a built in serial monitor because that is the staple of debugging for code on electronic boards.

          The editor and the computer running the editor are meant to be always-on to lower the activation energy for making something.
        </p>
        <p>
          I wanted to make a custom full-screen text editor to have more control of the aesthetics
          and to change the perception of what the device was (i.e. it's not a full computer).
          I decided against this because the code editing experience is so much more than just
          a text editor: copying resource files to the board, reading tutorials online, editing
          images and audio to be used on the board, etc.
        </p>

        <h5>Printer</h5>
        <p>
          Thermal printer is connected to a Raspberry Pi runs a program that listens for
          wishes to print things from the programmable space.
          I used a bigger printer so you can have longer line widths and more readable source code.
          This is nice, but it's a big machine and I wish it was smaller.
        </p>

        <h5>Proxy</h5>
        <p>
          It is fun to make boards to things, but it is a whole next level of cool ideas you can
          do when the boards can easily communicate with other objects in the room.
          These other object could be other boards or full graphic programs.
          I wanted the integration to no require any first time setup (aka typing in WiFi
          credentials to the board) or require an external internet connection so privacy
          is less of a concern. A natural fit for this is Bluetooth Low Energy (BLE)
          which can be found in many electronic boards today and it commonly supported by phones and computers.
        </p>
        <p>
          On the same computer as the editor, there is a background program that automatically
          connects to any CircuitPython BLE and proxies messages to the rest of the programmable
          space system. I wrote a CircuitPython library that allows you to write code like
          `room.claim(`temp is ' + myTemp)` which will serialize that message over BLE and
          then claimed to the programmable space fact table by the proxy.
          Similarly objects can listen for changes to the programmable space fact fact. 
        </p>

        <h4>Demos</h4>

        <h5>Peripheral display: Dangling string</h5>

        <p>
          The first kind of object that I want to help more people make is displays of information
          that use peripheral or background senses so the are calming and not exhausting like looking at a screen in your foreground.
          I find the ideas of tangible bits paper and Weisner's "calm technology" ideas inspiring and the goal
          of the CircuitPython editor is and programmble space is to make it as easy to make a display for the periphery as it is to
          show something on a computer screen.
        </p>
        <p>
          <center><img src="tangible-bits-periphery.jpg" alt="setup" class="gallery-imagee" /></center>
          <center><small>Graphic from Tangible Bits TODO add reference</small></center>
        </p>

        <p>
          In this "Dangling String" demo (inspired by Natalie Jeremijenko's work of the same name)
          uses a Trinket M0 board wired to a motor with a blue ribbon attached to it. The Trinket M0 was programmed
          using the CircuitPython editor to twirl the ribbon every 5 minutes as a calm and subtle way to notice the passage of time.
        </p>

        <p>
          <div style="padding:56.25% 0 0 0;position:relative;"><iframe
                  src="https://player.vimeo.com/video/403876366?byline=0&portrait=0"
                  style="position:absolute;top:0;left:0;width:100%;height:100%;" frameborder="0" allow="autoplay; fullscreen"
                  allowfullscreen></iframe></div>
          <center><small>Dangling string twirling</small></center>
        </p>
        <p>
          <img src="dangling-string-electronics.jpg" alt="setup" class="gallery-imagee" />
          <center><small>Dangling string electronics. The source of the purple light is the tiny Trinket M0 that is running the code.</small></center>
        </p>

        <h5>Personal Objects: Singing Faces</h5>

        <p>
          The second type of objects that I want to help more people make is personal objects:
          things that use art and samples from people you know to make the objects special to the people in the space.
          In this demo some handmade ceramic blobs sing using recorded voices of my family.
        </p>

        <p>
          <div style="padding:56.25% 0 0 0;position:relative;"><iframe
                  src="https://player.vimeo.com/video/541141677?byline=0&portrait=0"
                  style="position:absolute;top:0;left:0;width:100%;height:100%;" frameborder="0" allow="autoplay; fullscreen"
                  allowfullscreen></iframe></div>
          <center><small>Singing demo. Audio quality is low, but it's still a funny demo.</small></center>
        </p>
        <p>
            <img src="singing-faces-electronics.jpg" alt="setup" class="gallery-imagee" />
            <center><small>Electronics inside the singing heads: An Adafruit Circuit Playground Express connected to an audio amplifier that is hidden inside the head.</small></center>
        </p>

        <h5>(Locally) Connected Objects: Basic clock</h5>

        <p>
          Finally, I want to help more people make objects that can be integrate with the rest of the devices in the room.
          The earlier plant soil sensor showed sensors claiming facts to the programmable space but in this demo the
          Circuit Playground Bluefruit board subscribes to the fact "time is $X" in the room and displays it on the lights on the board.
          Behind it, there is another programmable space program that also subscribes to the same fact and displays the time as text on a screen.
          I think people have tunnel vision that screens are the only way to display information and I hope my making it easy to
          integrate electronic boards to a space that people will begin to thinking bigger.
        </p>
        <p>
          I think it's also useful to compare this to products like Adafruit.IO that claim to help people make connected devices.
          These services require Internet connectivity, creating accounts, sharing data with third parties, and sometimes paying money
          so I feel a better solution would be local to the devices.
          Although Internet connectivity is common, in my experience WiFi signals are too spotty for these small electronic boards
          to work in every room of the home and I have wasted far too much time trying to update and program WiFi credentials into every device
          where I got fed up with it. 
          In project and programmable spaces intentionally uses Bluetooth and local network connections so that no Internet connection is required.
        </p>

        <p>
          <div style="padding:56.25% 0 0 0;position:relative;"><iframe
                  src="https://player.vimeo.com/video/541141677?byline=0&portrait=0"
                  style="position:absolute;top:0;left:0;width:100%;height:100%;" frameborder="0" allow="autoplay; fullscreen"
                  allowfullscreen></iframe></div>
          <center><small>TODO Button and knob connected to room: play button for Spotify</small></center>
        </p>

        <br>
        <p>
            If you have thoughts or questions, feel free to email or reach out to me on <a
                href="https://twitter.com/jhaip">Twitter</a>.
        </p>

        <div style="margin-bottom: 5rem"></div>
        <p><a href="/"><< Home</a></p>
        <script src="https://player.vimeo.com/api/player.js"></script>
    </body>
</html>