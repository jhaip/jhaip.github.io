<!DOCTYPE html>
<html lang="en">

<head>
    <title>Jacob Haip</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="/style.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans" rel="stylesheet">
    <script src="/script.js" defer></script>
    <style>
        .fact {
            font-family: monospace;
            background: #fff9cc;
            padding: 5px;
        }
        .system-code {
            color: purple;
        }
        .code-comment {
            color: darkgreen;
        }
    </style>
</head>

<body class="writing">
    <a href="/"><< Home</a>
    <p>
        <img src="full_table_with_humidity_code_stand.jpg" alt="setup" class="gallery-imagee" />
    </p>
        <h1>Physical Programming<br>Research Update 3</h1>
        <p><small>August 18, 2019</small></p>

        <p>I am exploring the idea of "programmable spaces" &mdash; where the concept of a computer is expanded outside a little
        rectangular screen to fill the entire room. Interacting with the programmable space means using physical objects, not
        virtual ones on a screen. Bringing computing to scale of a room makes it a communal and social experience.
        </p>

        <p>
            Previously, I experimented with programmable spaces with
            <a href="https://haiperspace.com/writing/19-03-17-programmable-space/">clipboards representing code</a> and 
            with <a href="https://haiperspace.com/writing/19-01-20-research-update/">fixed 3x3 grid of papers</a>
            on a wall.
        </p>
        <p>
            But the demos have been focused on the textual aspects of code. Peices of paper with code on them were mapped to code running on a computer.
            It was nice to interact with physical objects instead of using a single computer monitor,
            but the real "work" still involved typing code in a little rectangle.
            The peices of paper could be moved around the physical world, but in my experiments so far programs were not aware
            of their physical location, the location of other programs, and overall didn't use their physical afforadances to change their behavior.
            A peice of code could be moved from a table to the wall, but it would have the behave the same either way.
        </p>

        <p>
            <div class="col-2">
                <div class="col">
                    <img src="many-programs-on-wall.jpg" />
                </div>
                <div class="col">
                    <img src="desktop-with-many-windows.jpg" />
                    <small>via https://www.flickr.com/photos/redspotted/7705129</small>
                </div>
            </div>
            <small>
                Unless there are other affordances, the view on the left is too similar to the overcrowded desktop on the right.
            </small>
        </p>

        <p>
            Therefore I wanted to play with non-textual ways of coding.
            I also wanted to use this idea to gauge how well the system is at supporting physical affordances and to be
            a platform to prototype new ideas in this area.
        </p>
        
        <h3>Spatial Awareness</h3>
        <p>
            In a programmable space, programs are in the physical world so they should have properties like other physical things:
        </p>
        <ul class="dashed">
            <li>You can hold them in your hands. You can move them around.</li>
            <li>Objects can have physical affordances to suggest that they be used a certain way. Switches can be actual switches.
                Paper is a nice physical representation of a program because it can be drawn on, pinned up on walls, or recycled when it isn't needed.</li>
            <li>
                Programs can "see" what other programs are around them and change their behavior.
                If several programs are arranged arranged in a row this could imply a relation or "flow" of data or influence.
                A region in space like a particular table can be used to imply a grouping that means something to the programs on that table vs programs on a different table. 
            </li>
        </ul>
        <br>
        <img src="lines-to-other-papers.jpg">
        <p>
            In the photo shown above, programs are represented by papers with colored dots on the corners. (The colored dots help a camera recognize the papers)
            The locations of all programs are claimed to the room so any program can use them. In this case one paper draws a line from itself to all the other papers on the same wall.
        </p>
        <div class='embed-container'><iframe
                src='https://www.youtube-nocookie.com/embed/srNoF4zLaDU?rel=0' frameborder='0'
                allowfullscreen></iframe></div>
        <p>
            This video above shows two "data sources": one that is a number that counts from 0 to 100 repeatedly and another is the angle of the paper in degrees.
            Both of these data sources show their value and make their current value available to the room.
            Another program is a gauge graph that displays whatever number is claimed by the program above it.
            You can hold the guage graph in your hand and point it at whatever data source you'd like to be shown on the graph.
            The spatial relation helps connect the idea that the graph is separete from the data, reusable, and depends on what is is pointing at and nothing else.
        </p>
        <div class='embed-container'><iframe src='https://www.youtube.com/embed/XUQAKwLFuNI?rel=0' frameborder='0'
                allowfullscreen></iframe></div>
        <p>
            The video above shows how you collect and visualize data over time in a programmable space.
            A program could be a "data store" that saves the last 20 values from whatever data source is above it.
            Other programs can look at the "data store" they are pointing at an visualize them or produce a modified set of data.
            The video above shows a bar graph, filter that only keeps odd values, and a program that shows the average of the data.
        </p>
        <p>
            When they are all used the flow of data matches the arrangement of the papers.
            This is similar to node/graph based visual programming environments like MaxMSP where you can modify a program by rearranging "nodes",
            but the nodes themselves are chunks of code that you may or may not care about.
            It is hard to see in the video, but when a program depends on something that is is pointing at, a blue line
            is projected from the paper into the space the paper is "looking at". This helps show the connection, or potential connection, between papers.
        </p>
        <p>
            One property that I'm especially interested in is a programmable space ability to support understanding by
            being able recreate itself and not depend on an order.
            For example, all of these programs in the demo above are independent and magically update when they point at a program that claims something to the
            room in a format they can work with.
            Someone new can begin to understand what is going on by removing a program and seeing what happens.
            "Undoing" is a simple as putting a piece of paper back were you found it.
            Because this is normal, there is no harm in someone new to the space to break things.
            Breaking things encourages you to get a sense of what is important without reading the logic connected to each program.
        </p>

        <h3>Text-Free Robot Programming</h3>
        <p>
            But the rearranging of code spatially is still based on the concept of textual code and it can be intimidating.
            Therefore I tried out a less intimidating system where there is no text by recreating the coding robot for kids by <a href="matatalab.com">Matatalab</a>.
        </p>
        <p>
            <img src="matatalab-set.jpg" />
            <small>
                Matatalab's Coding Set: Colored tiles with symbols on them (left) are placed on a board (middle) to program the robot (right).
            </small>
        </p>
        <p>
            I can't speak for how affective the Matatalab product is at teaching kids basic coding concepts, but I think their product
            will well designed and I admire them for making a physical and screen-free way to learn.
        </p>
        <p>
            <img src="robot-angle-shot.jpg">
            <small>
                My text-free robot programming environment
            </small>
        </p>
        <p>
            To recreate this idea, I built a board, stand, and "action blocks" out of LEGOs.
            The action blocks had symbols on them to represent actions like "move forward", "turn right", "start a loop", and numbers.
            A webcam looked down at the blocks on the board and feed data into a program that used computer vision to guess the current state of the board.
            The state of the board was claimed to the room so other programs could use it.
        </p>
        <p>
            The robot you programmed was built from a Raspberry Pi and a <a href="https://www.adafruit.com/product/3244">robot chassis</a> using a couple DC Motors.
            A Particle Photon board hooked up to a button would notify the room whenever it's button was pressed.
            Finally, other programs running in the room visualized the state of the board, converted the board into code that made the robot perform the movements, showed the robot code,
            and told the robot to current the code when the button was pressed.
        </p>
        <p>
            <img src="robot-diagram.png" />
            <small>
                Overall architecture of this demo. Messages syndicated between brokers are shown on the top in blue.
            </small>
        </p>
        <p>
            Each computer in the room was running the exact same "room <a href="https://en.wikipedia.org/wiki/Message_broker">message broker</a>" that allowed programs to make claims
            to the room and for claims to be syndicated between computers.
            The only difference between the computers was what programs were running on them and what things were connected to them like cameras, motors, or projectors.
        </p>
        <div class='embed-container'><iframe src='https://www.youtube.com/embed/277migTZoKs?rel=0' frameborder='0'
                allowfullscreen></iframe></div>
        <p>
            I liked this text-free robot demo because it was fun to play with and because it showed some nice properties of the programmable space system:
        </p>
        <p>
            <ul class="dashed">
                <li>
                    Claiming things about the room is a nicer abstraction that works well across computers.
                    It's nice that programs running on the same computer and programming running on different computers all communicate in the same way.
                    The protocol is defined.
                </li>
                <li>
                    Because programs communicated via a shared fact table, it encourages programs to be broken apart.
                    For example in the text-free robot demo, the board vision code was separate from the board-to-robot-code compiler and the robot itself.
                    Because programs communicate globally, it is easy to integrate and prototype related programs.
                    The board visualization and the compiled code display weren't needed for the demo, but they were the easiest programs to make and were helpful tools to see into the system.
                </li>
                <li>
                    Live updates come for free
                </li>
            </ul>
        </p>
        <p>
            But even without having text, it's still has the feel of coding: syntax errors, etc. Objects themselves were also
            "technical".
        </p>
        <p>
            <ul class="dashed">
                <li>
                    <strong>Papers:</strong>
                    Although it was made from regular printed paper - they required special colored dots in the corners for tracking. The
                    papers could be drawn on and cut in the middle, but the dots in the corners were required. If you had an existing object
                    → you could either try to put dots around it or you'd have to have the technical knowledge to track it.
                </li>
                <li>
                    <strong>Text-Free Tiles</strong>
                    Like the dots, it was a special object that could only recognize the prebuilt tiles. Special technical knowledge needed
                    to detect them and someone new would have to understand the system to extend it.
                </li>
            </ul>
        </p>

        <h3>Laser Regions</h3>
        
        <p>
            Therefore I wanted to try out an interaction model where any object in the room could be connected to the room.
            Examples: Something you drew or a book.
        </p>
        <p>
            I built a system where you could use a laser pointer to define "regions" in space and an event is fired when one is
            hovered/selected. Laser pointer is like a mouse. Programs in the room can subscribe to what regions are selected or toggled
            and act that.
        </p>
        <div class='embed-container'><iframe src='https://www.youtube.com/embed/OVLIwkPlILg?rel=0' frameborder='0'
                allowfullscreen></iframe></div>
        <p>
            In this first demo we start with a tiger face made our of construction paper.
            We define a region roughly around the tiger's face and name the region "tiger".
            Another program subscribes to facts about a laser being in a region named "tiger" and shows "RAWR!".
            Because the program is also a piece of paper, we can cut it to make it and the "RAWR" bigger.
        </p>
        <div class='embed-container'><iframe src='https://www.youtube.com/embed/OVLIwkPlILg?rel=0' frameborder='0'
                allowfullscreen></iframe></div>
        <p>
            My partner and I have a map with pins of restaurants we have been to together over the years.
            The map is cool by itself but in this demo I added some magic to allow you to select a region on the map
            to see the neighborhood name and the restaurants we went too.
        </p>
        <p>
            I liked how the laser regions allowed the map to be a normal and beautiful object by itself
            and only if you interact can you see some additional annotations about it.
        </p>

        <h3>Future Work</h3>
        <p>
            Other areas I'd like to explore:
            <ul class="dashed">
                <li>Visibility of code errors</li>
                <li>Ways make programs without needing to write code from a scratch.</li>
                <li>Scalability of the system to handle facts with larger data like images or .CSV files</li>
                <li>Distributing the system to scale to more than one computer</li>
                <li>Maybe playing with cameras and computer vision to track programs again</li>
            </ul>
        </p>
        <br>
        <p>
            If you have thoughts or questions, feel free to email or reach out to me on <a
                href="https://twitter.com/jhaip">Twitter</a>.
        </p>

        <div style="margin-bottom: 5rem"></div>
        <p><a href="/"><< Home</a></p>
    </body>
</html>