<!DOCTYPE html>
<html lang="en">

<head>
    <title>Jacob Haip</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="/style.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=IBM+Plex+Sans" rel="stylesheet">
    <script src="/script.js" defer></script>
    <style>
        .fact {
            font-family: monospace;
            background: #fff9cc;
            padding: 5px;
        }
        .system-code {
            color: purple;
        }
        .code-comment {
            color: darkgreen;
        }
    </style>
</head>

<body class="writing">
    <a href="/"><< Home</a>
    <p>
        <img src="full_table_with_humidity_code_stand.jpg" alt="setup" class="gallery-imagee" />
    </p>
        <h1>Physical Programming<br>Research Update 3</h1>
        <p><small>August 18, 2019</small></p>

        <p>I am exploring the idea of "programmable spaces" &mdash; where the concept of a computer is expanded outside a little
        rectangular screen to fill the entire room. Interacting with the programmable space means using physical objects, not
        virtual ones on a screen. Bringing computing to scale of a room makes it a communal and social experience.
        </p>

        <p>
            Previously, I experimented with programmable spaces with
            <a href="https://haiperspace.com/writing/19-03-17-programmable-space/">clipboards representing code</a> and 
            with <a href="https://haiperspace.com/writing/19-01-20-research-update/">fixed 3x3 grid of papers</a>
            on a wall.
        </p>
        <p>
            But the demos have been focused on the textual aspects of code. Peices of paper with code on them were mapped to code running on a computer.
            It was nice to interact with physical objects instead of using a single computer monitor,
            but the real "work" still involved typing code in a little rectangle.
            The peices of paper could be moved around the physical world, but in my experiments so far programs were not aware
            of their physical location, the location of other programs, and overall didn't use their physical afforadances to change their behavior.
            A peice of code could be moved from a table to the wall, but it would have the behave the same either way.
        </p>

        <p>
            <div class="col-2">
                <div class="col">
                    <img src="many-programs-on-wall.jpg" />
                </div>
                <div class="col">
                    <img src="desktop-with-many-windows.jpg" />
                    <small>via https://www.flickr.com/photos/redspotted/7705129</small>
                </div>
            </div>
            <small>
                Unless there are other affordances, the view on the left is too similar to the overcrowded desktop on the right.
            </small>
        </p>

        <p>
            Therefore I wanted to play with non-textual ways of coding.
            I also wanted to use this idea to gauge how well the system is at supporting physical affordances and to be
            a platform to prototype new ideas in this area.
        </p>
        
        <h3>Spatial Awareness</h3>
        <p>
            In a programmable space, programs are in the physical world so they should have properties like other physical things:
        </p>
        <ul class="dashed">
            <li>You can hold them in your hands. You can move them around.</li>
            <li>Objects can have physical affordances to suggest that they be used a certain way. Switches can be actual switches.
                Paper is a nice physical representation of a program because it can be drawn on, pinned up on walls, or recycled when it isn't needed.</li>
            <li>
                Programs can "see" what other programs are around them and change their behavior.
                If several programs are arranged arranged in a row this could imply a relation or "flow" of data or influence.
                A region in space like a particular table can be used to imply a grouping that means something to the programs on that table vs programs on a different table. 
            </li>
        </ul>
        <br>
        <img src="lines-to-other-papers.jpg">
        <p>
            In the photo shown above, programs are represented by papers with colored dots on the corners. (The colored dots help a camera recognize the papers)
            The locations of all programs are claimed to the room so any program can use them. In this case one paper draws a line from itself to all the other papers on the same wall.
        </p>
        <div class='embed-container'><iframe
                src='https://www.youtube-nocookie.com/embed/srNoF4zLaDU?rel=0' frameborder='0'
                allowfullscreen></iframe></div>
        <p>
            This first demo shows two "data sources": one that is a number that counts from 0 to 100 repeatedly and another is the angle of the paper in degrees.
            Both of these data sources show their value and also claim their current value to the room.
            Another program is a gauge graph that displays the whatever number is claimed by a program that is above it.
            You can hold the guage graph in your hand and point it at whatever data source you'd like to be shown on the graph.
            The spatial relation helps connect the idea that the graph is separete from the data, reusable, and depends on what is is pointing at and nothing else.
        </p>
        <p>INSERT DEMO VIDEO 2</p>
        <p>
            This next demo adds a few new programs:
            A "data store" - a program that saves the last 20 values from whatever data source is above it.
            A program that calculates and shows the average of the values in a "data store"
            A bar graph that plots values from whatever "data store" is to its left.
            A produces a new data store after applying a filter to the data store above it.
        </p>
        <p>
            All these programs can be used independently and swapped out. When they are all used the flow of data matches the arrangement of the papers.
            This is similar to node/graph based visual programming environments like MaxMSP where you can modify a program by rearranging "nodes",
            but the nodes themselves are chunks of code that you may or may not care about.
        </p>
        <p>
            One property that I'm especially interested in is a programmable space's ability to recreate itself.
            You can understand a system by just removing one piece and seeing what happens.
            Restoring the system is a simple as putting a piece of paper on a table.
            Because this is normal, there is no harm in someone new to the space to break things.
            Breaking things encourages you to get a sense of what is important without reading the logic connected to each program.
        </p>

        <h3>Words-Free Robot Programming</h3>
        <p>
            But the rearranging of code spatially is still based on the concept of code - it still looks like code.
            Therefore I tried out a system where there is no text by recreating the coding robot for kids by <a href="matatalab.com">Matatalab</a>.
        </p>
        <p>
            <img src="matatalab-set.jpg" />
            <small>
                Colored tiles with symbols on them (left) are placed on a board (middle) to program the robot (right).
            </small>
        </p>
        <p>
            I can't speak for how affective the Matatalab product is at teaching kids basic coding concepts, but I think their product
            will well designed and I admire them for making a physical and screen-free way to learn.
        </p>
        <p>
            To recreate this idea, I made a robot from robot chassis for a raspberry pi.
            The raspberry pi ran the same broker as all the other computers running the programmable space.
            Programs in the room can wish code runs on the raspberry pi. (Messages are federated between computers)
            In this case we have the tiles converted into code and then we run the code on the robot.
            Tiles are seen using a webcam connected to another computer running the system broker and a computer vision program.
            The tiles seen are claimed and available to any program in the room.
            One program is visualizes what the camera "sees".
            Another program converts the seen tiles into some Python code that can move the robot.
            A program shows this compiled code as well.
            When a button is pressed (a claim is made to the space that a button has been pressed),
            another programs wishes the robot code would be running on the robot.
            The flow from button press to robot movement takes around 4 seconds for the data to be proxied
            and because of some inefficient code I wrote, but it's good enough for a demo.
        </p>

        <p>
            But even without having text, it's still has the feel of coding: syntax errors, etc. Objects themselves were also
            "technical".
        </p>

        <h3>Laser Regions</h3>
        
        <p>
            Unfortunately, the Particle Photon microcontrollers were not a totally equal member in the room. Claims from a Photon went from the Photon's C code →
            HTTP → A program that translates the HTTP request to the system protocol → the rest of the system. I learned that
            decentralization will need to become an important part of the system. Computation needs to be able to scale beyond a
            single central computer or the "size of the room" will always be limited. Dynamicland's approach to distributed computing is touched on
            in <a href="https://rsnous.com/posts/notes-from-dynamicland-programming-raspberry-pis/">this post</a>,
            but I haven't grasped the concept and I'd like to explore this area in the future.
        </p>
        <p>
            Other areas I'd like to explore:
            <ul class="dashed">
                <li>Visibility of code errors</li>
                <li>Ways make programs without needing to write code from a scratch.</li>
                <li>Scalability of the system to handle facts with larger data like images or .CSV files</li>
                <li>Distributing the system to scale to more than one computer</li>
                <li>Maybe playing with cameras and computer vision to track programs again</li>
            </ul>
        </p>
        <br>
        <p>
            If you have thoughts or questions, feel free to email or reach out to me on <a
                href="https://twitter.com/jhaip">Twitter</a>.
        </p>

        <div style="margin-bottom: 5rem"></div>
        <p><a href="/"><< Home</a></p>
    </body>
</html>